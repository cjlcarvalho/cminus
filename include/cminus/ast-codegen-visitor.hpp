#pragma once
#include <cminus/ast-visitor.hpp>

namespace cminus
{
/// This is a code generator for MIPS.
/// 
/// The generated code is fully compatible with the O32 ABI, thus functions
/// generated by this may be used by foreign functions in the system.
///
/// This generator does no perform register allocation, therefore the
/// spit code makes very poor use of registers.
///
class ASTCodegenVisitor : public ASTVisitor
{
public:
    explicit ASTCodegenVisitor(std::string& dest) :
        dest(dest)
    {
    }

    void visit_program(ASTProgram& program) override;

    void visit_var_decl(ASTVarDecl& decl) override;
    void visit_parm_decl(ASTParmVarDecl& decl) override;
    void visit_fun_decl(ASTFunDecl& decl) override;

    void visit_null_stmt(ASTNullStmt& stmt) override;
    void visit_compound_stmt(ASTCompoundStmt& stmt) override;
    void visit_selection_stmt(ASTSelectionStmt& stmt) override;
    void visit_iteration_stmt(ASTIterationStmt& stmt) override;
    void visit_return_stmt(ASTReturnStmt& stmt) override;

    void visit_number_expr(ASTNumber& expr) override;
    void visit_var_expr(ASTVarRef& expr) override;
    void visit_call_expr(ASTFunCall& expr) override;
    void visit_binary_expr(ASTBinaryExpr& expr) override;

    void visit_type(ExprType type) override;
    void visit_name(SourceRange name) override;

public:

    struct FrameInfo
    {
        // $sp => output temp saved local input

        int32_t input_size = 0;
        int32_t local_size = 0;
        int32_t saved_size = 0;
        int32_t temp_size = 0;
        int32_t output_size = 0;

        uint32_t total_size() const
        {
            return input_size + local_size + saved_size + temp_size + output_size;
        }

        int32_t output_offset(int32_t offset) const
        {
            return 0 + offset;
        }

        int32_t temp_offset(int32_t offset) const
        {
            return output_offset(output_size) + offset;
        }

        int32_t saved_offset(int32_t offset) const
        {
            return temp_offset(temp_size) + offset;
        }

        int32_t local_offset(int32_t offset) const
        {
            return saved_offset(saved_size) + offset;
        }

        int32_t input_offset(int32_t offset) const
        {
            return local_offset(local_size) + offset;
        }
    };

private:
    void load_address_of(ASTVarRef& expr);

private:
    std::string& dest;
    std::unordered_map<ASTFunDecl*, FrameInfo> frames;
    std::unordered_map<ASTVarDecl*, int32_t> local_pos;

    FrameInfo current_frame;
    int32_t current_temp_pos = 0;

    void emit_frame_sw(int reg, int32_t frame_offset)
    {
        dest += "sw $";
        dest += std::to_string(reg);
        dest += ", ";
        dest += std::to_string(frame_offset);
        dest += "($sp)\n";
    }

    void emit_frame_lw(int reg, int32_t frame_offset)
    {
        dest += "lw $";
        dest += std::to_string(reg);
        dest += ", ";
        dest += std::to_string(frame_offset);
        dest += "($sp)\n";
    }

    int32_t temp_alloc(int32_t size)
    {
        auto result = current_temp_pos;
        this->current_temp_pos += size;
        assert(current_temp_pos <= current_frame.temp_size);
        return current_frame.temp_offset(result);
    }

    void temp_free(int32_t offset, int32_t size)
    {
        this->current_temp_pos -= size;
        assert(current_temp_pos == offset);
    }

};
}
