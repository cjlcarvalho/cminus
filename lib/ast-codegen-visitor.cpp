#include <cminus/ast-codegen-visitor.hpp>

constexpr auto REG_V0 = 2;
constexpr auto REG_T0 = 8;
constexpr auto REG_A0 = 4;
constexpr auto REG_RA = 31;

namespace
{
using namespace cminus;

/// This is a stack frame allocator.
///
/// For each function definition, it calculates the suitable size (and offsets)
/// for its activation record.
///
/// It also calculates the offsets in the frame for each local variable in the
/// function.
///
/// The activation record of a function generated by us is composed by six blocks:
///
///     $sp ->
///           | output | temporaries | saved | local | input         |
///           | callee stack frame                    | caller frame |
///
/// + The input block contains the arguments to the function. The first four
///   arguments are in the callee stack frame while the rest is in the caller's.
/// + The local block contains automatic variables.
/// + The saved block is used for saving the procedure return address ($ra).
/// + The temporaries block holds data used for computing nested expressions.
///   This is essentially a stack where the stack top pointer is known by the
///   code generator (so we don't need an additional register for that).
/// + The output block is a space reserved for inputs of functions called by
///   the current procedure.
///
class FrameAllocatorVisitor : public ASTVisitor
{
public:
    using FrameInfo = ASTCodegenVisitor::FrameInfo;

    explicit FrameAllocatorVisitor(
            std::unordered_map<ASTFunDecl*, FrameInfo>& out_frames,
            std::unordered_map<ASTVarDecl*, int32_t>& out_local_pos) :
        frames(out_frames),
        local_pos(out_local_pos)
    {
    }

    void visit_fun_decl(ASTFunDecl& decl) override
    {
        this->frame = FrameInfo{};
        this->frame.saved_size = 4; // $ra

        // Calculate the size of the other blocks by recursing into the body.
        this->inside_function = true;
        visit_compound_stmt(*decl.get_body());
        this->inside_function = false;

        // Calculate size of input block and assign offset to param vars.
        // Must be after recursing into the body so we have the size of
        // the local block already computed.
        for(auto it = decl.parm_begin(); it != decl.parm_end(); ++it)
        {
            auto var_decl = static_cast<ASTVarDecl*>((*it).get());
            this->local_pos[var_decl] = frame.local_size + frame.input_size;
            this->frame.input_size = std::min(16, frame.input_size + 4);
        }

        this->frames[&decl] = std::move(this->frame);
    }

    void visit_compound_stmt(ASTCompoundStmt& stmt) override
    {
        const auto outer_local_pos = current_local_pos;
        walk_compound_stmt(stmt);
        this->frame.local_size = std::max(frame.local_size, current_local_pos);
        this->current_local_pos = outer_local_pos;
    }

    void visit_var_decl(ASTVarDecl& decl) override
    {
        if(inside_function)
        {
            auto num_elms = (!decl.is_array() ? 1 : decl.get_array_size()->get_value());
            this->local_pos[&decl] = current_local_pos;
            this->current_local_pos += 4 * num_elms;
        }
    }

    void visit_call_expr(ASTFunCall& expr) override
    {
        auto num_parms = static_cast<int32_t>(expr.get_decl()->get_num_params());
        if(num_parms > 4)
        {
            const int32_t requires_output = 4 * (num_parms - 4);
            this->frame.output_size = std::max(frame.output_size, requires_output);
        }

        walk_call_expr(expr);
    }

    void visit_binary_expr(ASTBinaryExpr& expr) override
    {
        // binary expressions need 4 bytes of temporary space to be evaluated.
        const auto temp_bytes = 4;
        temp_enter(temp_bytes);
        walk_binary_expr(expr);
        temp_leave(temp_bytes);
    }

    void visit_var_expr(ASTVarRef& var_ref) override
    {
        // variable references also need 4 bytes of temporary space sometimes.
        const auto temp_bytes = var_ref.get_index() ? 4 : 0;
        temp_enter(temp_bytes);
        walk_var_expr(var_ref);
        temp_leave(temp_bytes);
    }

    /// Emulates the push of something into the temporary space.
    void temp_enter(uint32_t bytes)
    {
        this->current_temp_pos += bytes;
    }

    /// Emulates the pop of something from the temporary space.
    void temp_leave(uint32_t bytes)
    {
        this->frame.temp_size = std::max(frame.temp_size, current_temp_pos);
        this->current_temp_pos -= bytes;
    }

private:
    // Output structures.
    std::unordered_map<ASTFunDecl*, FrameInfo>& frames;
    std::unordered_map<ASTVarDecl*, int32_t>& local_pos;

    // Auxiliar variables for computing the above structures.
    FrameInfo frame;
    bool inside_function = false;
    int32_t current_local_pos = 0;
    int32_t current_temp_pos = 0;
};
}

namespace cminus
{
void ASTCodegenVisitor::visit_program(ASTProgram& program)
{
    dest += ".data\n";
    dest += ".align 2\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto var_decl = (*it)->as_var_decl())
            visit_var_decl(*var_decl);
    }

    auto frame_allocator = FrameAllocatorVisitor(this->frames, this->local_pos);

    dest += "\n.text\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto fun_decl = (*it)->as_fun_decl())
        {
            frame_allocator.visit_fun_decl(*fun_decl);
            visit_fun_decl(*fun_decl);
        }
    }
}

void ASTCodegenVisitor::visit_var_decl(ASTVarDecl& decl)
{
    if(!inside_function)
    {
        dest += decl.get_name();
        dest += ": ";

        auto num_elms = (!decl.is_array() ? 1 : decl.get_array_size()->get_value());
        dest += ".space ";
        dest += std::to_string(4 * num_elms);

        dest += '\n';
    }
}

void ASTCodegenVisitor::visit_parm_decl(ASTParmVarDecl& decl)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_fun_decl(ASTFunDecl& decl)
{
    this->current_frame = this->frames[&decl];
    auto frame_size_s = std::to_string(current_frame.total_size());

    const auto RA_OFFSET = current_frame.saved_offset(0);

    this->inside_function = true;
    this->function_label_goto_ob = -1;

    /*
    dest += "# ";
    dest += std::to_string(current_frame.output_size);
    dest += ' ';
    dest += std::to_string(current_frame.temp_size);
    dest += ' ';
    dest += std::to_string(current_frame.saved_size);
    dest += ' ';
    dest += std::to_string(current_frame.local_size);
    dest += ' ';
    dest += std::to_string(current_frame.input_size);
    dest += '\n';
    */

    dest += decl.get_name();
    dest += ":\n";

    // Function prologue.
    dest += "addiu $sp, $sp, -";
    dest += frame_size_s;
    dest += "\n";
    emit_frame_sw(REG_RA, RA_OFFSET);
    for(size_t i = 0; i < 4 && i < decl.get_num_params(); ++i)
        emit_frame_sw(REG_A0 + i, current_frame.input_offset(4 * i));

    this->function_epilogue_label = next_label_id();

    visit_compound_stmt(*decl.get_body());

    // Function epilogue
    dest += ".L";
    dest += std::to_string(function_epilogue_label);
    dest += ":\n";

    emit_frame_lw(REG_RA, RA_OFFSET);
    dest += "addiu $sp, $sp, ";
    dest += frame_size_s;
    dest += "\n";

    dest += "jr $ra\n";

    // We need to generate this stub at the bottom of the function
    // because a normal (non-jump) MIPS instruction has too little
    // space for a big offset. The crt may be too far away.
    if(function_label_goto_ob != -1)
    {
        dest += ".L";
        dest += std::to_string(function_label_goto_ob);
        dest += ":\n";
        dest += "j __crt_out_of_bounds\n";
    }

    this->inside_function = false;
}

void ASTCodegenVisitor::visit_null_stmt(ASTNullStmt&)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_compound_stmt(ASTCompoundStmt& comp_stmt)
{
    walk_compound_stmt(comp_stmt);
}

void ASTCodegenVisitor::visit_selection_stmt(ASTSelectionStmt& if_stmt)
{
    const auto false_label = next_label_id();
    int32_t fi_label = -1;

    visit_expr(*if_stmt.get_cond());

    dest += "beq $v0, $0, .L";
    dest += std::to_string(false_label);
    dest += '\n';

    visit_stmt(*if_stmt.get_then());

    if(if_stmt.get_else())
    {
        fi_label = next_label_id();

        dest += "j .L";
        dest += std::to_string(fi_label);
        dest += '\n';
    }

    dest += ".L";
    dest += std::to_string(false_label);
    dest += ":\n";

    if(if_stmt.get_else())
    {
        visit_stmt(*if_stmt.get_else());

        dest += ".L";
        dest += std::to_string(fi_label);
        dest += ":\n";
    }
}

void ASTCodegenVisitor::visit_iteration_stmt(ASTIterationStmt& while_stmt)
{
    auto const if_label = next_label_id();
    auto const fi_label = next_label_id();

    dest += ".L";
    dest += std::to_string(if_label);
    dest += ":\n";

    visit_expr(*while_stmt.get_cond());

    dest += "beq $v0, $0, .L";
    dest += std::to_string(fi_label);
    dest += '\n';

    visit_stmt(*while_stmt.get_body());

    dest += "j .L";
    dest += std::to_string(if_label);
    dest += '\n';

    dest += ".L";
    dest += std::to_string(fi_label);
    dest += ":\n";
}

void ASTCodegenVisitor::visit_return_stmt(ASTReturnStmt& retn_stmt)
{
    if(retn_stmt.get_expr())
        visit_expr(*retn_stmt.get_expr());

    // Function epilogue
    dest += "j .L";
    dest += std::to_string(function_epilogue_label);
    dest += '\n';
}

void ASTCodegenVisitor::visit_binary_expr(ASTBinaryExpr& expr)
{
    const auto temp_bytes = 4;
    const auto temp_pos = temp_alloc(temp_bytes);

    if(expr.get_operation() == ASTBinaryExpr::Operation::Assign)
    {
        load_address_of(*expr.get_left()->as_var_expr());
    }
    else
    {
        visit_expr(*expr.get_left());
    }

    emit_frame_sw(REG_V0, temp_pos);
    visit_expr(*expr.get_right());
    emit_frame_lw(REG_T0, temp_pos);

    switch(expr.get_operation())
    {
        case ASTBinaryExpr::Operation::Plus:
            dest += "addu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Minus:
            dest += "subu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Multiply:
            dest += "mult $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Divide:
            dest += "div $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Less:
            dest += "slt $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::LessEqual:
            dest += "slt $v0, $v0, $t0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Greater:
            dest += "slt $v0, $v0, $t0\n";
            break;
        case ASTBinaryExpr::Operation::GreaterEqual:
            dest += "slt $v0, $t0, $v0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Equal:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltiu $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::NotEqual:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltu $v0, $0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Assign:
            dest += "sw $v0, 0($t0)\n";
            break;
    }

    temp_free(temp_pos, temp_bytes);
}

void ASTCodegenVisitor::visit_number_expr(ASTNumber& num)
{
    dest += "li $v0, ";
    dest += std::to_string(num.get_value());
    dest += '\n';
}

void ASTCodegenVisitor::visit_var_expr(ASTVarRef& var)
{
    load_address_of(var);
    if(var.type() != ExprType::Array)
        dest += "lw $v0, 0($v0)\n";
}

void ASTCodegenVisitor::visit_call_expr(ASTFunCall& fun_call)
{
    auto fun_decl = fun_call.get_decl();

    size_t argcount = 0;
    for(auto it = fun_call.arg_begin();
        it != fun_call.arg_end();
        ++it, ++argcount)
    {
        visit_expr(**it);

        if(argcount < 4)
        {
            dest += "add $";
            dest += regname(REG_A0 + argcount);
            dest += ", $v0, $0\n";
        }
        else
        {
            emit_frame_sw(REG_V0, current_frame.output_offset(4 * (argcount - 4)));
        }
    }

    dest += "jal ";
    dest += fun_decl->get_name();
    dest += '\n';
}

void ASTCodegenVisitor::visit_type(ExprType type)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_name(SourceRange name)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::load_address_of(ASTVarRef& var_ref)
{
    auto var_decl = var_ref.get_decl();

    auto it = local_pos.find(var_decl.get());
    if(it != local_pos.end())
    {
        auto frame_offset = current_frame.local_offset(it->second);
        dest += "addiu $v0, $sp, ";
        dest += std::to_string(frame_offset);
        dest += '\n';
        ;

        if(var_decl->is_pointer())
            dest += "lw $v0, 0($v0)\n";
    }
    else
    {
        dest += "la $v0, ";
        dest += var_decl->get_name();
        dest += '\n';
    }

    if(auto index_expr = var_ref.get_index())
    {
        const auto temp_bytes = 4;
        const auto temp_pos = temp_alloc(temp_bytes);

        if(this->function_label_goto_ob == -1)
            this->function_label_goto_ob = next_label_id();

        emit_frame_sw(REG_V0, temp_pos);
        visit_expr(*index_expr);

        // Check negative index.
        dest += "bltzal $v0, .L";
        dest += std::to_string(function_label_goto_ob);
        dest += '\n';

        dest += "sll $v0, $v0, 2\n";
        emit_frame_lw(REG_T0, temp_pos);
        dest += "addu $v0, $t0, $v0\n";

        temp_free(temp_pos, temp_bytes);
    }
}

uint32_t ASTCodegenVisitor::FrameInfo::total_size() const
{
    return input_size + local_size + saved_size + temp_size + output_size;
}

int32_t ASTCodegenVisitor::FrameInfo::output_offset(int32_t offset) const
{
    return 0 + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::temp_offset(int32_t offset) const
{
    return output_offset(output_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::saved_offset(int32_t offset) const
{
    return temp_offset(temp_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::local_offset(int32_t offset) const
{
    return saved_offset(saved_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::input_offset(int32_t offset) const
{
    return local_offset(local_size) + offset;
}

void ASTCodegenVisitor::emit_frame_sw(int reg, int32_t frame_offset)
{
    dest += "sw $";
    dest += regname(reg);
    dest += ", ";
    dest += std::to_string(frame_offset);
    dest += "($sp)\n";
}

void ASTCodegenVisitor::emit_frame_lw(int reg, int32_t frame_offset)
{
    dest += "lw $";
    dest += regname(reg);
    dest += ", ";
    dest += std::to_string(frame_offset);
    dest += "($sp)\n";
}

int32_t ASTCodegenVisitor::temp_alloc(int32_t size)
{
    auto result = current_temp_pos;
    this->current_temp_pos += size;
    assert(current_temp_pos <= current_frame.temp_size);
    return current_frame.temp_offset(result);
}

void ASTCodegenVisitor::temp_free(int32_t offset, int32_t size)
{
    this->current_temp_pos -= size;
    assert(current_frame.temp_offset(current_temp_pos) == offset);
}

int32_t ASTCodegenVisitor::next_label_id()
{
    return ++current_label_id;
}

auto ASTCodegenVisitor::regname(int reg) -> const char*
{
    assert(reg >= 0 && reg <= 31);
    switch(reg)
    {
        case 0:
            return "0";
        case 1:
            return "at";
        case 2:
            return "v0";
        case 3:
            return "v1";
        case 4:
            return "a0";
        case 5:
            return "a1";
        case 6:
            return "a2";
        case 7:
            return "a3";
        case 8:
            return "t0";
        case 9:
            return "t1";
        case 10:
            return "t2";
        case 11:
            return "t3";
        case 12:
            return "t4";
        case 13:
            return "t5";
        case 14:
            return "t6";
        case 15:
            return "t7";
        case 16:
            return "s0";
        case 17:
            return "s1";
        case 18:
            return "s2";
        case 19:
            return "s3";
        case 20:
            return "s4";
        case 21:
            return "s5";
        case 22:
            return "s6";
        case 23:
            return "s7";
        case 24:
            return "t8";
        case 25:
            return "t9";
        case 26:
            return "k0";
        case 27:
            return "k1";
        case 28:
            return "gp";
        case 29:
            return "sp";
        case 30:
            return "fp";
        case 31:
            return "ra";
        default:
            assert(false);
    }
}
}
