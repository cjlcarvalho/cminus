#include <cminus/ast-codegen-visitor.hpp>

constexpr auto REG_RA = 31;
constexpr auto REG_A0 = 4;
constexpr auto REG_T0 = 8;
constexpr auto REG_V0 = 2;

namespace
{
using namespace cminus;
class FrameAllocatorVisitor : public ASTVisitor
{
public:
    using FrameInfo = ASTCodegenVisitor::FrameInfo;

    explicit FrameAllocatorVisitor(
            std::unordered_map<ASTFunDecl*, FrameInfo>& out_frames,
            std::unordered_map<ASTVarDecl*, int32_t>& out_local_pos) :
        frames(out_frames),
        local_pos(out_local_pos)
    {
    }

    void visit_fun_decl(ASTFunDecl& decl) override
    {
        this->frame = FrameInfo{};
        this->frame.saved_size = 4; // $ra

        for(auto it = decl.parm_begin(); it != decl.parm_end(); ++it)
        {
            auto var_decl = static_cast<ASTVarDecl*>((*it).get());
            this->local_pos[var_decl] = frame.input_size;
            this->frame.input_size += 4;
        }

        this->inside_function = true;
        visit_compound_stmt(*decl.get_body());
        this->inside_function = false;

        this->frames[&decl] = std::move(this->frame);
    }

    void visit_var_decl(ASTVarDecl& decl) override
    {
        if(inside_function)
        {
            auto num_elms = (!decl.is_array()? 1 : decl.get_array_size()->get_value());
            this->current_local_pos += 4 * num_elms;
            this->local_pos[&decl] = current_local_pos;
        }
    }

    void visit_compound_stmt(ASTCompoundStmt& stmt) override
    {
        const auto old_local_pos = current_local_pos;
        walk_compound_stmt(stmt);
        this->frame.local_size = std::max(frame.local_size, current_local_pos);
        this->current_local_pos = old_local_pos;
    }

    void visit_call_expr(ASTFunCall& expr) override
    {
        auto num_parms = static_cast<int32_t>(expr.get_decl()->get_num_params());
        if(num_parms > 4)
            this->frame.output_size = std::max(frame.output_size, num_parms * 4);

        walk_call_expr(expr);
    }

    void visit_binary_expr(ASTBinaryExpr& expr) override
    {
        const auto temp_bytes = 4;
        temp_enter(temp_bytes);
        walk_binary_expr(expr);
        temp_leave(temp_bytes);
    }

    void visit_var_expr(ASTVarRef& var_ref) override
    {
        const auto temp_bytes = var_ref.get_index()? 4 : 0;
        temp_enter(temp_bytes);
        walk_var_expr(var_ref);
        temp_leave(temp_bytes);
    }

private:
    void temp_enter(uint32_t bytes)
    {
        this->current_temp_pos += bytes;
    }

    void temp_leave(uint32_t bytes)
    {
        this->frame.temp_size = std::max(frame.temp_size, current_temp_pos);
        this->current_temp_pos -= bytes;
    }

private:
    // Output structures.
    std::unordered_map<ASTFunDecl*, FrameInfo>& frames;
    std::unordered_map<ASTVarDecl*, int32_t>& local_pos;

    // Auxiliar variables for computing the above structure.
    FrameInfo frame;
    bool inside_function = false;
    int32_t current_local_pos = 0;
    int32_t current_temp_pos = 0;
};
}

namespace cminus
{
void ASTCodegenVisitor::visit_program(ASTProgram& program)
{
    dest += ".data\n";
    dest += ".align 2\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto var_decl = (*it)->as_var_decl())
            visit_var_decl(*var_decl);
    }

    auto frame_allocator = FrameAllocatorVisitor(this->frames, this->local_pos);

    dest += "\n.text\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto fun_decl = (*it)->as_fun_decl())
        {
            frame_allocator.visit_fun_decl(*fun_decl);
            visit_fun_decl(*fun_decl);
        }
    }
}

void ASTCodegenVisitor::visit_var_decl(ASTVarDecl& decl)
{
    dest += '_';
    dest += decl.get_name();
    dest += ": ";

    auto num_elms = (!decl.is_array()? 1 : decl.get_array_size()->get_value());
    dest += ".space ";
    dest += std::to_string(4 * num_elms);

    dest += '\n';
}

void ASTCodegenVisitor::visit_parm_decl(ASTParmVarDecl& decl)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_fun_decl(ASTFunDecl& decl)
{
    // The stack frame of a function generated by this is composed by six blocks:
    //
    //    $sp -> 
    //           | output | temporaries | saved | local | input         |
    //           | callee stack frame                    | caller frame |
    //
    // + The input block contains the arguments to the function. The first four
    //   arguments are in the callee stack frame while the rest is in the caller's.
    // + The local block contains automatic variables.
    // + The saved block is used for saving the procedure return address ($ra).
    // + The temporaries block holds data used for computing nested expressions.
    //   This is essentially a stack where the stack top pointer is known by the
    //   code generator (so we don't need an additional register for that).
    // + The output block is a space reserved for inputs of functions called by
    //    the current procedure.
    //
    
    const auto RA_OFFSET = current_frame.saved_offset(0);
    
    dest += '_';
    dest += decl.get_name();
    dest += ":\n";

    this->current_frame = this->frames[&decl];
    auto frame_size_s = std::to_string(current_frame.total_size());

    // Function prologue.
    dest += "addiu $sp, $sp, -";
    dest += frame_size_s;
    dest += "\n";
    emit_frame_sw(REG_RA, RA_OFFSET);
    emit_frame_sw(REG_A0 + 0, current_frame.input_offset(0));
    emit_frame_sw(REG_A0 + 1, current_frame.input_offset(4));
    emit_frame_sw(REG_A0 + 2, current_frame.input_offset(8));
    emit_frame_sw(REG_A0 + 3, current_frame.input_offset(12));

    visit_compound_stmt(*decl.get_body());

    // Function epilogue
    emit_frame_lw(REG_RA, RA_OFFSET);
    dest += "addiu $sp, $sp, ";
    dest += frame_size_s;
    dest += "\n";

    dest += "jr $ra\n";
}

void ASTCodegenVisitor::visit_null_stmt(ASTNullStmt&)
{
}

void ASTCodegenVisitor::visit_compound_stmt(ASTCompoundStmt& comp_stmt)
{
}

void ASTCodegenVisitor::visit_selection_stmt(ASTSelectionStmt& if_stmt)
{
}

void ASTCodegenVisitor::visit_iteration_stmt(ASTIterationStmt& while_stmt)
{
}

void ASTCodegenVisitor::visit_return_stmt(ASTReturnStmt& retn_stmt)
{
}

void ASTCodegenVisitor::visit_binary_expr(ASTBinaryExpr& expr)
{
    const auto temp_bytes = 4;
    const auto temp_pos = temp_alloc(temp_bytes);

    if(expr.get_operation() != ASTBinaryExpr::Operation::Assign)
    {
        visit_expr(*expr.get_left());
    }
    else
    {
        load_address_of(*expr.get_left()->as_var_expr());
    }

    emit_frame_sw(REG_V0, temp_pos);
    visit_expr(*expr.get_right());
    emit_frame_lw(REG_T0, temp_pos);

    switch(expr.get_operation())
    {
        case ASTBinaryExpr::Operation::Plus:
            dest += "addu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Minus:
            dest += "subu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Multiply:
            dest += "mult $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Divide:
            dest += "div $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Less:
            dest += "slt $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::LessEqual:
            dest += "slt $v0, $v0, $t0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Greater:
            dest += "slt $v0, $v0, $t0\n";
            break;
        case ASTBinaryExpr::Operation::GreaterEqual:
            dest += "slt $v0, $t0, $v0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Equal:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltu $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::NotEqual:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltu $v0, $0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Assign:
            dest += "sw $v0, 0($t0)\n";
            break;
    }

    temp_free(temp_pos, temp_bytes);
}

void ASTCodegenVisitor::load_address_of(ASTVarRef& var_ref)
{
    auto var_decl = var_ref.get_decl();

    auto it = local_pos.find(var_decl.get());
    if(it != local_pos.end())
    {
        auto frame_offset = current_frame.local_offset(it->second);
        dest += "addiu $v0, $sp, ";
        dest += std::to_string(frame_offset);
        dest += '\n';;
    }
    else
    {
        dest += "la $v0, _";
        dest += var_decl->get_name();
        dest += '\n';
    }

    if(auto index_expr = var_ref.get_index())
    {
        const auto temp_bytes = var_ref.get_index()? 4 : 0;
        const auto temp_pos = temp_alloc(temp_bytes);
        emit_frame_sw(REG_V0, temp_pos);
        visit_expr(*index_expr);
        dest += "sll $v0, $v0, 2\n";
        emit_frame_lw(REG_T0, temp_pos);
        dest += "addu $v0, $t0, $v0\n";
        temp_free(temp_pos, temp_bytes);
    }
}

void ASTCodegenVisitor::visit_number_expr(ASTNumber& num)
{
    dest += "li $v0, ";
    dest += std::to_string(num.get_value());
    dest += '\n';
}

void ASTCodegenVisitor::visit_var_expr(ASTVarRef& var)
{
    load_address_of(var);
    dest += "lw $v0, 0($v0)\n";
}

void ASTCodegenVisitor::visit_call_expr(ASTFunCall& fun_call)
{
}

void ASTCodegenVisitor::visit_type(ExprType type)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_name(SourceRange name)
{
    // No code needs to be generated for this.
}
}
