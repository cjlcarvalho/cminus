#include <cminus/ast-codegen-visitor.hpp>

constexpr auto REG_V0 = 2;
constexpr auto REG_T0 = 8;
constexpr auto REG_A0 = 4;
constexpr auto REG_RA = 31;

namespace
{
using namespace cminus;

/// This is a stack frame allocator.
///
/// For each function definition, it calculates the suitable size (and offsets)
/// for its activation record.
///
/// It also calculates the offsets in the frame for each local variable in the
/// function.
/// 
/// The activation record of a function generated by us is composed by six blocks:
///
///     $sp -> 
///           | output | temporaries | saved | local | input         |
///           | callee stack frame                    | caller frame |
///
/// + The input block contains the arguments to the function. The first four
///   arguments are in the callee stack frame while the rest is in the caller's.
/// + The local block contains automatic variables.
/// + The saved block is used for saving the procedure return address ($ra).
/// + The temporaries block holds data used for computing nested expressions.
///   This is essentially a stack where the stack top pointer is known by the
///   code generator (so we don't need an additional register for that).
/// + The output block is a space reserved for inputs of functions called by
///   the current procedure.
///
class FrameAllocatorVisitor : public ASTVisitor
{
public:
    using FrameInfo = ASTCodegenVisitor::FrameInfo;

    explicit FrameAllocatorVisitor(
            std::unordered_map<ASTFunDecl*, FrameInfo>& out_frames,
            std::unordered_map<ASTVarDecl*, int32_t>& out_local_pos) :
        frames(out_frames),
        local_pos(out_local_pos)
    {
    }

    void visit_fun_decl(ASTFunDecl& decl) override
    {
        this->frame = FrameInfo{};
        this->frame.saved_size = 4; // $ra

        // Calculate size of input block.
        for(auto it = decl.parm_begin(); it != decl.parm_end(); ++it)
        {
            auto var_decl = static_cast<ASTVarDecl*>((*it).get());
            this->local_pos[var_decl] = frame.input_size;
            this->frame.input_size += 4;
        }

        // Calculate the size of the other blocks by recursing into the body.
        this->inside_function = true;
        visit_compound_stmt(*decl.get_body());
        this->inside_function = false;

        this->frames[&decl] = std::move(this->frame);
    }

    void visit_compound_stmt(ASTCompoundStmt& stmt) override
    {
        const auto outer_local_pos = current_local_pos;
        walk_compound_stmt(stmt);
        this->frame.local_size = std::max(frame.local_size, current_local_pos);
        this->current_local_pos = outer_local_pos;
    }

    void visit_var_decl(ASTVarDecl& decl) override
    {
        if(inside_function)
        {
            auto num_elms = (!decl.is_array()? 1 : decl.get_array_size()->get_value());
            this->local_pos[&decl] = current_local_pos;
            this->current_local_pos += 4 * num_elms;
        }
    }

    void visit_call_expr(ASTFunCall& expr) override
    {
        auto num_parms = static_cast<int32_t>(expr.get_decl()->get_num_params());
        if(num_parms > 4)
        {
            const int32_t requires_output = 4 * (num_parms - 4);
            this->frame.output_size = std::max(frame.output_size, requires_output);
        }

        walk_call_expr(expr);
    }

    void visit_binary_expr(ASTBinaryExpr& expr) override
    {
        // binary expressions need 4 bytes of temporary space to be evaluated.
        const auto temp_bytes = 4;
        temp_enter(temp_bytes);
        walk_binary_expr(expr);
        temp_leave(temp_bytes);
    }

    void visit_var_expr(ASTVarRef& var_ref) override
    {
        // variable references also need 4 bytes of temporary space sometimes.
        const auto temp_bytes = var_ref.get_index()? 4 : 0;
        temp_enter(temp_bytes);
        walk_var_expr(var_ref);
        temp_leave(temp_bytes);
    }

    /// Emulates the push of something into the temporary space.
    void temp_enter(uint32_t bytes)
    {
        this->current_temp_pos += bytes;
    }

    /// Emulates the pop of something from the temporary space.
    void temp_leave(uint32_t bytes)
    {
        this->frame.temp_size = std::max(frame.temp_size, current_temp_pos);
        this->current_temp_pos -= bytes;
    }

private:
    // Output structures.
    std::unordered_map<ASTFunDecl*, FrameInfo>& frames;
    std::unordered_map<ASTVarDecl*, int32_t>& local_pos;

    // Auxiliar variables for computing the above structures.
    FrameInfo frame;
    bool inside_function = false;
    int32_t current_local_pos = 0;
    int32_t current_temp_pos = 0;
};
}

namespace cminus
{
void ASTCodegenVisitor::visit_program(ASTProgram& program)
{
    dest += ".data\n";
    dest += ".align 2\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto var_decl = (*it)->as_var_decl())
            visit_var_decl(*var_decl);
    }

    auto frame_allocator = FrameAllocatorVisitor(this->frames, this->local_pos);

    dest += "\n.text\n";
    for(auto it = program.decl_begin(); it != program.decl_end(); ++it)
    {
        if(auto fun_decl = (*it)->as_fun_decl())
        {
            this->inside_function = true;
            frame_allocator.visit_fun_decl(*fun_decl);
            visit_fun_decl(*fun_decl);
            this->inside_function = false;
        }
    }
}

void ASTCodegenVisitor::visit_var_decl(ASTVarDecl& decl)
{
    if(!inside_function)
    {
        dest += '_';
        dest += decl.get_name();
        dest += ": ";

        auto num_elms = (!decl.is_array()? 1 : decl.get_array_size()->get_value());
        dest += ".space ";
        dest += std::to_string(4 * num_elms);

        dest += '\n';
    }
}

void ASTCodegenVisitor::visit_parm_decl(ASTParmVarDecl& decl)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_fun_decl(ASTFunDecl& decl)
{
    const auto RA_OFFSET = current_frame.saved_offset(0);
    
    dest += '_';
    dest += decl.get_name();
    dest += ":\n";

    this->current_frame = this->frames[&decl];
    auto frame_size_s = std::to_string(current_frame.total_size());

    // Function prologue.
    dest += "addiu $sp, $sp, -";
    dest += frame_size_s;
    dest += "\n";
    emit_frame_sw(REG_RA, RA_OFFSET);
    for(size_t i = 0; i < decl.get_num_params(); ++i)
        emit_frame_sw(REG_A0 + i, current_frame.input_offset(4 * i));

    visit_compound_stmt(*decl.get_body());

    // Function epilogue
    emit_frame_lw(REG_RA, RA_OFFSET);
    dest += "addiu $sp, $sp, ";
    dest += frame_size_s;
    dest += "\n";

    dest += "jr $ra\n";
}

void ASTCodegenVisitor::visit_null_stmt(ASTNullStmt&)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_compound_stmt(ASTCompoundStmt& comp_stmt)
{
    walk_compound_stmt(comp_stmt);
}

void ASTCodegenVisitor::visit_selection_stmt(ASTSelectionStmt& if_stmt)
{
    // TODO
}

void ASTCodegenVisitor::visit_iteration_stmt(ASTIterationStmt& while_stmt)
{
    // TODO
}

void ASTCodegenVisitor::visit_return_stmt(ASTReturnStmt& retn_stmt)
{
    // TODO
}

void ASTCodegenVisitor::visit_binary_expr(ASTBinaryExpr& expr)
{
    const auto temp_bytes = 4;
    const auto temp_pos = temp_alloc(temp_bytes);

    if(expr.get_operation() == ASTBinaryExpr::Operation::Assign)
    {
        load_address_of(*expr.get_left()->as_var_expr());
    }
    else
    {
        visit_expr(*expr.get_left());
    }

    emit_frame_sw(REG_V0, temp_pos);
    visit_expr(*expr.get_right());
    emit_frame_lw(REG_T0, temp_pos);

    switch(expr.get_operation())
    {
        case ASTBinaryExpr::Operation::Plus:
            dest += "addu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Minus:
            dest += "subu $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Multiply:
            dest += "mult $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Divide:
            dest += "div $t0, $v0\n";
            dest += "mflo $v0\n";
            break;
        case ASTBinaryExpr::Operation::Less:
            dest += "slt $v0, $t0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::LessEqual:
            dest += "slt $v0, $v0, $t0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Greater:
            dest += "slt $v0, $v0, $t0\n";
            break;
        case ASTBinaryExpr::Operation::GreaterEqual:
            dest += "slt $v0, $t0, $v0\n";
            dest += "xori $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::Equal:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltu $v0, $v0, 1\n";
            break;
        case ASTBinaryExpr::Operation::NotEqual:
            dest += "xor $v0, $t0, $v0\n";
            dest += "sltu $v0, $0, $v0\n";
            break;
        case ASTBinaryExpr::Operation::Assign:
            dest += "sw $v0, 0($t0)\n";
            break;
    }

    temp_free(temp_pos, temp_bytes);
}

void ASTCodegenVisitor::visit_number_expr(ASTNumber& num)
{
    dest += "li $v0, ";
    dest += std::to_string(num.get_value());
    dest += '\n';
}

void ASTCodegenVisitor::visit_var_expr(ASTVarRef& var)
{
    load_address_of(var);
    dest += "lw $v0, 0($v0)\n";
}

void ASTCodegenVisitor::visit_call_expr(ASTFunCall& fun_call)
{
    // TODO
}

void ASTCodegenVisitor::visit_type(ExprType type)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::visit_name(SourceRange name)
{
    // No code needs to be generated for this.
}

void ASTCodegenVisitor::load_address_of(ASTVarRef& var_ref)
{
    auto var_decl = var_ref.get_decl();

    auto it = local_pos.find(var_decl.get());
    if(it != local_pos.end())
    {
        auto frame_offset = current_frame.local_offset(it->second);
        dest += "addiu $v0, $sp, ";
        dest += std::to_string(frame_offset);
        dest += '\n';;
    }
    else
    {
        dest += "la $v0, _";
        dest += var_decl->get_name();
        dest += '\n';
    }

    if(auto index_expr = var_ref.get_index())
    {
        const auto temp_bytes = var_ref.get_index()? 4 : 0;
        const auto temp_pos = temp_alloc(temp_bytes);

        emit_frame_sw(REG_V0, temp_pos);
        visit_expr(*index_expr);
        dest += "sll $v0, $v0, 2\n";
        emit_frame_lw(REG_T0, temp_pos);
        dest += "addu $v0, $t0, $v0\n";

        temp_free(temp_pos, temp_bytes);
    }
}

uint32_t ASTCodegenVisitor::FrameInfo::total_size() const
{
    return input_size + local_size + saved_size + temp_size + output_size;
}

int32_t ASTCodegenVisitor::FrameInfo::output_offset(int32_t offset) const
{
    return 0 + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::temp_offset(int32_t offset) const
{
    return output_offset(output_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::saved_offset(int32_t offset) const
{
    return temp_offset(temp_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::local_offset(int32_t offset) const
{
    return saved_offset(saved_size) + offset;
}

int32_t ASTCodegenVisitor::FrameInfo::input_offset(int32_t offset) const
{
    return local_offset(local_size) + offset;
}

void ASTCodegenVisitor::emit_frame_sw(int reg, int32_t frame_offset)
{
    dest += "sw $";
    dest += regname(reg);
    dest += ", ";
    dest += std::to_string(frame_offset);
    dest += "($sp)\n";
}

void ASTCodegenVisitor::emit_frame_lw(int reg, int32_t frame_offset)
{
    dest += "lw $";
    dest += regname(reg);
    dest += ", ";
    dest += std::to_string(frame_offset);
    dest += "($sp)\n";
}

int32_t ASTCodegenVisitor::temp_alloc(int32_t size)
{
    auto result = current_temp_pos;
    this->current_temp_pos += size;
    assert(current_temp_pos <= current_frame.temp_size);
    return current_frame.temp_offset(result);
}

void ASTCodegenVisitor::temp_free(int32_t offset, int32_t size)
{
    this->current_temp_pos -= size;
    assert(current_temp_pos == offset);
}

auto ASTCodegenVisitor::regname(int reg) -> const char*
{
    assert(reg >= 0 && reg <= 31);
    switch(reg)
    {
        case 0: return "0";
        case 1: return "at";
        case 2: return "v0";
        case 3: return "v1";
        case 4: return "a0";
        case 5: return "a1";
        case 6: return "a2";
        case 7: return "a3";
        case 8: return "t0";
        case 9: return "t1";
        case 10: return "t2";
        case 11: return "t3";
        case 12: return "t4";
        case 13: return "t5";
        case 14: return "t6";
        case 15: return "t7";
        case 16: return "s0";
        case 17: return "s1";
        case 18: return "s2";
        case 19: return "s3";
        case 20: return "s4";
        case 21: return "s5";
        case 22: return "s6";
        case 23: return "s7";
        case 24: return "t8";
        case 25: return "t9";
        case 26: return "k0";
        case 27: return "k1";
        case 28: return "gp";
        case 29: return "sp";
        case 30: return "fp";
        case 31: return "ra";
        default: assert(false);
    }
}
}
